# 详解边界智能跨链服务 - iService
<div class="article_about">
    <div class="article_about_owner_container">
        <div class="article_about_icon_wrap">
            <img src='https://irita.bianjie.ai/img/blog/bianjie_icon.png' class="article_about_icon">
        </div>
        <span class="article_about_owner">边界智能</span>
    </div>
    <span class='article_about_time'>2021-05-18</span>
</div>

---
<br>


##  一、什么是 iService

### 1、简要介绍

iService 是 IRITAHUB 的一个功能模块，旨在弥合区块链和传统业务应用系统之间的鸿沟。它规范化了链外服务的定义和绑定（提供者注册），促进了调用以及与这些服务的交互，并能调解服务治理过程（分析和争议解决）。

支持数据隐私安全，请求方将请求的隐私数据加密处理上链，服务方将链上记录的加密数据在链下进行解密处理，然后将处理结果加密后上链，请求方在链下将处理结果解密拿到数据，整个过程数据都是密文不可见。相较于智能合约，iService在数据隐私安全性方面更开放灵活。

### 2、 iService 产生背景

由于区块链技术使用门槛高，技术难度大，传统业务系统及应用开发者本身的开发资源有限，想通过区块链技术达到自己想要的预期结果变得非常困难；传统业务系统及应用利用区块链技术高效的完成跨业务系统协作的心愿变得遥远。在这种情况下需要诞生一种新的技术，能够降低传统业务系统与应用使用区块链技术的门槛，灵活的业务接入方式，可扩展式的、插件式的功能定制和使用，iService 应运而生并完美解决了上述问题。

### 3、 iService 服务网络架构设计

<div align=center><img src="https://www.bianjie.ai/resources/IRITA/IRITA-HOME-Map/blog0/iService01.png" ></div>


## 二、iService 有哪些功能

iService 模块作为 IRITA 的核心功能服务模块，在 IRITA 底层链服务核心层，处在区块链底层和业务应用层之间。利用 iService，接入区块链网络的业务方可以很方便的发布面向服务的分布式应用，不用开发很多智能合约，这样可以极大降低系统集成的复杂度，降低用户接入区块链的成本，快速实现链上链下数据传输与信息交互。

<div align=center><img src="https://www.bianjie.ai/resources/IRITA/IRITA-HOME-Map/blog0/IRITA.png" ></div>

<center> <font size=2>IRITA 核心模块架构图</font></center>

### 1、iService 的功能列表

服务基本操作相关

* 服务定义
* 服务绑定
* 服务请求
* 服务响应

服务控制开关

* 服务启用
* 服务禁用

已发起的服务相关控制

* 服务更新
* 服务暂停
* 服务启动
* 服务终止

服务收益相关

* 退还服务绑定工分
* 提取服务收益工分

查看服务相关

* 查看服务定义、绑定、请求、响应等
* 查看服务定价、服务费收益、服务费收益提取地址等

服务治理

区块链系统 iService 模块的相关参数的治理

### 2、功能原理描述

#### （1）服务定义

**服务定义创建后将是不可修改的**，服务更新应该新建服务定义，旧的服务定义也将存在在区块链中，体现服务的多个版本。

服务提供者应该可以在服务绑定中绑定新旧多个版本的服务定义，通过Binding失效的机制让服务消费者跟随提供者的服务升级而选择升级，而非升级之后导致服务直接不可用。

服务定义及绑定中结构化定义和表示应当是跨语言的:

* json: 广泛的语言支持、高可读性。缺点：跨语言的数据类型难以统一。使用json实现时应该注意json格式化标准方式（如当前项目中的go-amino中的实现标准与go语言实现的标准不一致）
* protobuf/thrift: 跨语言，对比json数据压缩率高，服务调用双方代码维护成本较低。
* amino: 暂时无其他语言的实现。

#### （2）服务绑定

通过创建对现有服务定义的绑定，任何用户都可以提供相应的服务。绑定主要由四个部分组成：**服务****提供者地址、****服务****定价、****通证质押****以及服务质量**。

* **提供者地址**

提供者地址是服务提供者（即链外服务/进程）用来监听请求的一个端点。因为链上仅仅定义方法名称、输入结构和输出结构；该方法名称对应的业务逻辑功能是在链外服务/进程实现。

* **服务定价**

定价指定服务提供者如何对其提供的服务收费。定价必须符合链上定义的schema。

* **通证质押**

运营一个iService服务，提供者有着重要的服务责任，因此创建服务绑定需要一定数量的通证质押。质押数量必须大于规定阈值。如果服务提供者未能在超时之前响应请求，则其绑定的质押通证的一小部分将被罚没和销毁。如果质押通证数量降至阈值以下，服务绑定将被暂时禁用，直到其所有者增加足够的质押通证重新激活。

* **服务质量**

服务质量承诺是根据提供者将服务响应发送回区块链所需的平均区块数来声明的。这是消费者选择潜在提供者时考虑的另一个因素。

#### （3）服务调用

服务调用主要有两个部分：**请求上下文、 请求批次**。

* **请求上下文**

消费者通过创建一个请求上下文来指定如何调用一个服务。请求上下文 像智能合约一样自动生成实际的请求。请求上下文 由一些参数组成，可以大致分为如下四组：

1. **目标和输入**   

服务名：要调用的目标服务的名称；
     
输入数据：符合目标服务输入 schema 的 json 格式数据

  2. **提供者过滤**  

提供者列表：逗号分隔的候选服务提供者的地址列表；
     
服务费上限：消费者愿意为每次调用支付的最大服务费用；

超时：消费者为接收响应愿意等待的区块数

  3. **响应处理**     

模块：包含回调函数的模块名称；
     
响应阈值：为调用回调函数所需接收的最小响应数；

提示：这两个参数不能从 CLI 和 API 设置；它们只对使用 iService 的其他模块可用，比如 oracle 和 random。

  4. **重复性**重复          

指示请求上下文是否可重复的一个布尔标志频率：重复调用批次之间的区块间隔数总数：重复调用批次的总数，负数表示无限

* **请求批次**

对于一个重复性的请求上下文，新的请求批次将以指定的频率生成，直至达到指定的批次总数或者消费者（即该请求上下文的创建者）余额不足。

对于非重复性的请求上下文，将只生成一个请求批次。

一个请求批次由若干请求对象组成，请求 表示一个向符合遴选条件的服务提供者发起的服务调用。只有那些费用不高于服务费上限并且QoS 优于超时的提供者才能被选中。

#### （4）服务响应

服务提供者通过查询或者事件订阅来监听链上针对自己的请求。在处理完成一个请求之后，服务提供者发送回一个由结果对象和可选的符合服务输出 schema 的输出对象组成的响应。

* 服务结果 schema

服务结果对象必须符合此schema。下面是一个示例：

|{<br>"result" : {<br>"code": 400,<br>"message": "user input out of range"<br>}<br>}|
|:----|
当结果 code 等于200时输出对象必须提供。

#### （5）服务费用

任何创建服务绑定并运营服务提供者的用户应该指定一个提取地址。当用户提取服务提供者赚取的服务费时，服务费将被发送到该地址。如果没有设置此地址，它将是该用户的地址。

* 托管

在一个请求产生之后，关联的服务费不会立即支付给目标服务提供者，而是被托管在一个内部 托管账户。当响应及时（在请求超时前）被发送，相应的服务费（扣除服务税之后的部分）将从该托管账户释放到服务提供者。否则，服务费将退还给消费者。

* 手续费

在向服务提供者支付服务费之前，一部分手续将被收取并发送到链上指定地址，其数量为 ServiceFeeTax * fee。

提示： service/ServiceFeeTax 是可以通过链上治理更改的系统参数。

## 三、如何使用iService

### 1、iService流程简述

#### 服务定义绑定流程

* 服务提供方在区块链上定义服务接口，包括服务接口的输入规范和输出规范；
* 在**服务提供方**能够接受并处理服务请求之前，其运营者或所有者必须为它创建一个链上地址，并且发起一个绑定交易将这个地址关联到相关的服务定义。
* 一个服务可以有多个服务提供者地址绑定，每个服务提供者地址可以根据自己的业务各自链外实现该服务接口的功能，但功能接口输出要遵循服务定义的输出规范。

#### 服务调用流程

* 为调用一个服务，用户或消费者通过发起一个请求交易向一个或多个有效服务绑定的提供者地址发起请求；
* 服务提供者检测和处理这个请求，并且通过响应交易发送处理结果。
* 服务消费者和服务提供者被建议通过 端点（endpoints） 交互。有两种服务端点 —— 请求表（request table） 和 响应表（response table） （如下图所示）。

<div align=center><img src="https://www.bianjie.ai/resources/IRITA/IRITA-HOME-Map/blog0/iService03.png" ></div>
<br>

服务请求被添加到请求表(每个服务一个请求表)，感兴趣的服务提供者监控这些请求表并接收和处理发送给他们的请求; 服务结果（或错误）被返回由相应的服务消费者反过来监控的响应表中(每个消费者监听的服务一个响应表)。

服务提供方必须先进先服务。

### 2、iService应用案例

下面通过具体的应用案例来说明 iService 如何使用。

#### （1）数字资产转让。

* 场景描述：供应商A的链上资产转让给供应商B，使用iService实现该链上资产转让。
* 服务定义：**服务提供方**在区块链上定义**资产转让服务**接口，包括服务接口的输入规范和输出规范，通过DefineService交易上链。
* 服务绑定：供应商B指定**地址**绑定资产转让服务，作为服务的提供方。绑定操作时完成**定价、****通证质押****以及服务质量**的设置，通过BindService交易上链。
* 服务调用：供应商A通过创建一个请求上下文来指定调用资产转让服务和输入数据，指定服务者列表为供应商B的服务提供者地址、设置服务费上限、超时区块数、是否重复、（重复调用服务频率、重复调用服务总数），通过CallService交易上链。
* 服务响应：供应商B通过查询或者事件订阅来监听链上针对自己的资产转让服务请求。由供应商B来决定接受或拒绝资产转让请求，并发送回一个由结果对象和可选的符合服务输出 schema 的输出对象组成的响应，通过RespondService交易上链。

#### （2）数据授权可见。

* 场景描述：供应商A查看供应商B链上资产的某些隐私数据，需要供应商B授权，使用iService实现。
* 服务定义：**服务提供方**在区块链上定义数据授权服务接口，包括服务接口的输入规范和输出规范，通过DefineService交易上链。
* 服务绑定：供应商B指定**地址**绑定数据授权服务，作为服务的提供方。绑定操作时完成**定价、****通证质****押 以及 服务质量**的设置，通过BindService交易上链。
* 服务调用：供应商A通过创建一个请求上下文来指定调用数据授权服务和输入数据，指定服务者列表为供应商B的服务提供者地址、设置服务费上限、超时区块数、是否重复、（重复调用服务频率、重复调用服务总数），通过CallService交易上链。
* 服务响应：供应商B通过查询或者事件订阅来监听链上针对自己的数据授权服务请求。由供应商B来决定接受或拒绝数据授权请求，并发送回一个由结果对象和可选的符合服务输出 schema 的输出对象组成的响应，通过RespondService交易上链。

## 四、iService 与智能合约相比优缺点

### 1、两者之间的相似点：

* 两者都是通过交易方式来触发服务调用。
* 两者功能调用都需要地址、方法名、输入参数。
* 两者服务调用都是依附区块链之上完成的。

### 2、两者之间的优缺点：

* 智能合约代码执行是在链上执行；iService的功能代码在链外执行。
* 智能合约代码是存储在链上且公开透明；iService只有方法名、输入规范、输出规范存储在链上，功能代码存储在链外。
* 智能合约代码的编写受编程语言限制；iService功能代码编写没有编程语言限制。
* 智能合约方法调用在每个节点上都会执行；iService方法调用只有提供该服务的地址选择的节点上才会执行。
* 智能合约调用开始后，没法进行终止，直到gas耗完；iService方法调用开始后，可以进行控制（暂停、更新、启动、终止）。
* 智能合约功能服务稳定性可靠；iService功能方法的稳定完全由链外服务或进程保证。
* 智能合约去中心化；iService没有去中心化。
* 智能合约方法没法支持数据量大的功能处理；iService功能方法因为在链外执行，可以很好支持数据量大的功能业务需求。
* 智能合约的方法在虚拟机中；iService的方法执行根据功能代码的编程语言特性来决定，没有平台限制。
* 智能合约功能方法升级困难，功能扩展有限；iService的功能方法升级简单，功能扩展简单灵活。
* 智能合约功能方法不支持涉及隐私的数据处理；iService的功能方法支持密文处理，加密方式完全由服务提供方和服务请求方决定，加解密实现在链外进行，数据安全隐私得到保障。


